# Python的数据结构、函数和文件  
  
## 数据结构和序列  
  
### 元组  
  
* 举例：（4，5，6）  
* 元组化：tuple([4,5,6])-->(4,5,6)  
* 元组中存储的对象可能是可变对象。一旦创建了元组，元组中的对象就不能修改了；如果元组中的某个对象是可变的，比如列表，可以在原位进行修改  
* 拆分元组  
    * *rest：这也用在函数签名中以抓取任意长度列表的位置  
        参数。a,b,*rest = [1,2,3,4,5] ->rest = [3,4,5]  
  
* tuple方法  
    * count:统计某个值得出现频率  
  
### 列表  
  
* 与元组对比，列表的长度可变、内容可以被修改。你可以用方括号定义，或用list函数：举例：[1,2,3]  
* 列表和元组的语义接近，在许多函数中可以交叉使用。  
* 添加和删除元素  
    * 添加：append&insert（耗费的计算量大）  
    * 删除：remove  
* 检查：in & not in  
* 串联和组合列表  
    * 串联方式：+ 或者 extend  
* 排序：sort  
    * 例子：a.sort() -> [1,3,5,6]  
    * sort有一些选项，有时会很好用。其中之一是二级排序key，可以用这个key进行排序。例子：b.sort(key=len) #按长度排序  
* 二分搜索和维护已排序的列表  
    * bisect模块支持二分查找，和向已排序的列表插入值  
        * bisect.bisect(c,8) #在c中8所能排在的位置  
        * bisect.insort(c, 6) #在c中顺位插入6，把6插入到小于6和大于6的两个数字之间-->[1, 2, 2, 2, 3, 4, 6, 7]  
        * 注意：bisect模块不会检查列表是否已排好序，进行检查的话会耗费大量计算。因此，对未排序的列表用bisect不会产生错误，但结果不一定正确。  
* 切片  
    * a[1:5] #切片包括起始元素不包括结束元素  
    * a[-4:] #负数表明从后向前切片  
    * 在第二个冒号后面使用step  
        * seq[::2] #可以隔一个取一个元素  
        * seq[::-1] #可以将列表或元组颠倒过来  
* 序列函数（enumerate函数）  
    * enumerate函数，可以返回(i, value)元组序列:enumerate(some_list)-->((1,'a'),(2,'b'))  
* sorted函数：可以从任意序列的元素返回一个新的排好序的列表  
* zip函数  
    * 可以将多个列表、元组或其它序列成对组合成一个元组列表：zip(seq1, seq2)  
    * 可以处理任意多的序列，元素的个数取决于最短的序列  
    * 常见用法之一是同时迭代多个序列，可能结合enumerate使用  
    * zip可以被用来解压序：first_names, last_names = zip(*pitchers)  
* reversed函数：可以从后向前迭代一个序列  
    * 要记住reversed是一个生成器，只有实体化（即列表或for循  
        环）之后才能创建翻转的序列  
  
### 字典  
  
* 例子1：d1 = {'a' : 'some value', 'b' : [1, 2, 3, 4]}	例子2：d2 =dict([(1,2),(5,6),(3,4)])  
* 可以用del关键字或pop方法（返回值的同时删除键）删除值  
* keys和values是字典的键和值的迭代器方法  
    * list(d1.keys()) -->['a', 'b', 7]  
    * list(d1.values()) -->['some value', [1, 2, 3, 4], 'an integer']  
* 用update方法可以将一个字典与另一个融合  
    * d1.update({'b' : 'foo', 'c' : 12})  
* 默认值  
    * P79:setdefault方法  
    * collections模块的defaultdict类  
* 有效的键类型  
    * 字典的值可以是任意Python对象，而键通常是不可变的标量类型（整数、浮点型、字符串）或元组（元组中的对象必须是不可变的）。这被称为“可哈希性”。可以用hash函数检测一个对象是否是可哈希的（可被用作字典的键）  
    * 要用列表当做键，一种方法是将列表转化为元组，只要内部元素可以被哈希，它也就可以被哈希  
* 字典的值可以是任意Python对象，而键通常是不可变的标量类型（整数、浮点型、字符串）或元组（元组中的对象必须是不可变的）  
  
### 集合  
  
* 集合是无序的不可重复的元素的集合：创建集合：set([2, 2, 2, 1, 3, 3])或者{2, 2, 2, 1, 3, 3} -->{1, 2, 3}  
* 并集：可以用union方法，或者|运算符。a.union(b)或者a|b  
* 交集：可以用intersection或&运算符。a.intersection(b)或者a&b  
* 常用集合方法。P81表3-1  
* 子集：a.issubset(b) #如果a是b的子集，返回True  
* 父集：a.issuperset(b) #如果a是b的父集,返回Ture  
  
### 列表、集合和字典推导式  
  
* [expr for val in collection if condition]例子：[x.upper() for x in strings if len(x) > 2]  
* {expr for val in collection if condition}例子：{len(x) for x in strings}  
* 嵌套列表推导式：result = [name for names in all_data for name in names if name.count('e')>=2]-->result  = ['Steven']  
    * for表达式的顺序是与嵌套for循环的顺序一样（而不是列表推导式的顺序）  
  
## 文件和操作系统  
  
### f = open(path)打开文本  
  
### f.close()关闭文本  
  
### f.read(*)读取文本  
  
### f.tell()给出当前位置  
  
### f.seek(*)将文件位置更换为文件中的指定字节  
  
### 向文件写入，可以使用文件的write或writelines方法  
  
### 文件的字节和Unicode  
  
## 函数  
  
### 命名空间、作用域，和局部函数  
  
* 全局变量，局部变量，命名空间，局部命名空间。#任何在函数中赋值的变量默认都是被分配到局部命名空间中的  
    * 如果要在函数中对全局变量进行赋值操作，就必须用global关键字声明，尽量不要频繁使用global关键字  
* 返回多个值  
* 函数也是对象  
* 匿名函数lambda  
    * a = lambda x: x*2  
    * 直接传入lambda函数比编写完整函数声明要少输入很多字（也更清晰）多用lambda函数  
* 柯里化：部分参数应用  
    * 它指的是通过“部分参数应用”从现有函数派生出新函数的技术  
    * 例子add_five = lambda y: add_numbers(5, y)。这里的y就是一个柯里化的参数  
* 生成器  
    * 生成器（generator）是构造新的可迭代对象的一种简单方式。一般的函数执行之后只会返回单个值，而生成器则是以延迟的方式返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续。要创建一个生成器，只需将函数中的return替换为yeild即可。  
    * 另一种更简洁的构造生成器的方法是使用生成器表达（generator expression）。这是一种类似于列表、字典、集合推导式的生成器。其创建方式为，把列表推导式两端的方括号改成圆括号：gen = (x ** 2 for x in range(100))  
* itertools模块  
    * 标准库itertools模块中有一组用于许多常见数据算法的生成器。  
* 错误和异常处理  
    * try **** except ****  
    * 你想无论try部分的代码是否成功，都执行一  
        段代码。可以使用finally:try**** finally ****  
  
* IPython的异常  
